---
article: 5
title: "How to write filters that extend the functionality of the TStream classes"
summary: "Here's the basis for a set of classes that wrap around any TStream object to allow you to write formatted data to any stream."
meta-title: "Use Delphi Pascal to extend the functionality of the TStream classes | How to"
meta-desc: "An article that describes a set of classes that wrap a Delphi Pascal TStream to write formatted data to any stream."
demo-url: "https://github.com/delphidabbler/article-demos/tree/master/article-05"
pages: 1
index: true
redirect_from:
- /articles/5
---
<h2>
    Why do it?
  </h2>

  <p>
    In Java there are various predefined stream classes that provide filters for
    other stream classes &ndash; the filter classes essentially &quot;wrap&quot;
    the streams they operate on. The filters can often be applied to further
    filters. This article demonstrates how we can do this in Delphi in a way
    that is extendable &ndash; i.e. we can wrap filters around other filters.
  </p>


  <h2>
    How it's done
  </h2>

  <p>
    First of all, let's look at why we want to do this. Well say you want to
    write some data primitives as text to a stream and the text to be formatted
    to fit on a page, word wrapping properly. Then if we can wrap a filter that
    formats the primitives around another that formats the text and this filter
    is wrapped round a file stream object, then all we have to do is access the
    methods of the first class and the rest of the process happens
    automatically.
  </p>

  <p>
    The approach I've taken is to define a class, <var>TStreamWrapper</var>,
    that provides a base class for any filters that we want to define. Any
    <var>TStreamWrapper</var>  performs it's i/o using another
    <var>TStream</var> object &ndash; the wrapped object. The key point is that
    <var>TStreamWrapper</var> is itself derived from <var>TStream</var>, so that
    it can also wrap other <var>TSteamWrapper</var> objects &ndash; giving the
    extensibility we need. <var>TSteamWrapper</var> can also cause a wrapped
    stream to be freed when it is itself freed &ndash; allowing the wrapped
    streams to be created &quot;on the fly&quot; when the
    <var>TSteamWrapper</var> constructor is called.
  </p>

  <p>
    There is no additional functionality built in to <var>TSteamWrapper</var>
    &ndash; this is to be provided by derived classes. A small example class is
    demonstrated here.
  </p>

  <p>
    First to <var>TSteamWrapper</var>. Here's the class declaration:
  </p>

  <div class="frame">
  <!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
  <pre class="pas-source"><span class="pas-kwd">type</span>
    TStreamWrapper = <span class="pas-kwd">class</span>(TStream)
    <span class="pas-kwd">private</span>
      FBaseStream: TStream;
        <span class="pas-comment">{The wrapped stream}</span>
      FCloseStream: Boolean;
        <span class="pas-comment">{Free wrapped stream on destruction?}</span>
    <span class="pas-kwd">protected</span>
      <span class="pas-kwd">procedure</span> SetSize(NewSize: Longint); <span class="pas-kwd">override</span>;
        <span class="pas-comment">{Sets the size of the stream to the given value</span>
  <span class="pas-comment">      if the operation is supported by the underlying stream}</span>
      <span class="pas-kwd">property</span> BaseStream: TStream <span class="pas-kwd">read</span> FBaseStream;
        <span class="pas-comment">{Gives access to the underlying stream to descended </span>
  <span class="pas-comment">      classes}</span>
    <span class="pas-kwd">public</span>
      <span class="pas-kwd">constructor</span> Create(<span class="pas-kwd">const</span> Stream: TStream;
        <span class="pas-kwd">const</span> CloseStream: Boolean = False); <span class="pas-kwd">virtual</span>;
        <span class="pas-comment">{If CloseStream is true the given underlying stream is </span>
  <span class="pas-comment">      freed when this object is freed}</span>
      <span class="pas-kwd">destructor</span> Destroy; <span class="pas-kwd">override</span>;
      <span class="pas-comment">// Implementation of abstract methods of TStream</span>
      <span class="pas-kwd">function</span> <span class="pas-kwd">Read</span>(<span class="pas-kwd">var</span> Buffer; Count: Longint): Longint;
        <span class="pas-kwd">override</span>;
      <span class="pas-kwd">function</span> <span class="pas-kwd">Write</span>(<span class="pas-kwd">const</span> Buffer; Count: Longint): Longint;
        <span class="pas-kwd">override</span>;
      <span class="pas-kwd">function</span> Seek(Offset: Longint; Origin: Word): Longint;
        <span class="pas-kwd">override</span>;
    <span class="pas-kwd">end</span>;</pre>
  <div class="footer">Listing 1</div>
  </div>


  <p>
    and the implementation is:
  </p>

  <div class="frame">
  <!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
  <pre class="pas-source"><span class="pas-kwd">constructor</span> TStreamWrapper.Create(<span class="pas-kwd">const</span> Stream: TStream;
    <span class="pas-kwd">const</span> CloseStream: Boolean);
  <span class="pas-kwd">begin</span>
    <span class="pas-kwd">inherited</span> Create;
    <span class="pas-comment">// Record wrapped stream and if we free it on destruction</span>
    FBaseStream := Stream;
    FCloseStream := CloseStream;
  <span class="pas-kwd">end</span>;

  <span class="pas-kwd">destructor</span> TStreamWrapper.Destroy;
  <span class="pas-kwd">begin</span>
    <span class="pas-comment">// Close wrapped stream if required</span>
    <span class="pas-kwd">if</span> FCloseStream <span class="pas-kwd">then</span>
      FBaseStream.Free;
    <span class="pas-kwd">inherited</span> Destroy;
  <span class="pas-kwd">end</span>;

  <span class="pas-kwd">function</span> TStreamWrapper.<span class="pas-kwd">Read</span>(<span class="pas-kwd">var</span> Buffer;
    Count: Integer): Longint;
  <span class="pas-kwd">begin</span>
    <span class="pas-comment">// Simply call underlying stream's Read method</span>
    Result := FBaseStream.<span class="pas-kwd">Read</span>(Buffer, Count);
  <span class="pas-kwd">end</span>;

  <span class="pas-kwd">function</span> TStreamWrapper.Seek(Offset: Integer;
    Origin: Word): Longint;
  <span class="pas-kwd">begin</span>
    <span class="pas-comment">// Simply call the same method in the wrapped stream</span>
    Result := FBaseStream.Seek(Offset, Origin);
  <span class="pas-kwd">end</span>;

  <span class="pas-kwd">procedure</span> TStreamWrapper.SetSize(NewSize: Integer);
  <span class="pas-kwd">begin</span>
    <span class="pas-comment">// Set the size property of the wrapped stream</span>
    FBaseStream.Size := NewSize;
  <span class="pas-kwd">end</span>;

  <span class="pas-kwd">function</span> TStreamWrapper.<span class="pas-kwd">Write</span>(<span class="pas-kwd">const</span> Buffer;
    Count: Integer): Longint;
  <span class="pas-kwd">begin</span>
    <span class="pas-comment">// Simply call the same method in the wrapped stream</span>
    Result := FBaseStream.<span class="pas-kwd">Write</span>(Buffer, Count);
  <span class="pas-kwd">end</span>;</pre>
  <div class="footer">Listing 2</div>
  </div>


  <p>
    We can now derive a small filter class &ndash; <var>TStrStream</var>. As it
    stands it's not particularly useful, but does demonstrate the techniques.
    The class reads and writes strings (which are preceded by their lengths)
    from and to any stream. The declaration is:
  </p>

  <div class="frame">
  <!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
  <pre class="pas-source"><span class="pas-kwd">type</span>
    TStrStream = <span class="pas-kwd">class</span>(TStreamWrapper)
    <span class="pas-kwd">public</span>
      <span class="pas-kwd">procedure</span> WriteString(AString: <span class="pas-kwd">string</span>);
      <span class="pas-kwd">function</span> ReadString: <span class="pas-kwd">string</span>;
    <span class="pas-kwd">end</span>;</pre>
  <div class="footer">Listing 3</div>
  </div>

  <p>
    The class is implemented as follows:
  </p>

  <div class="frame">
  <!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
  <pre class="pas-source"><span class="pas-kwd">function</span> TStrStream.ReadString: <span class="pas-kwd">string</span>;
  <span class="pas-kwd">var</span>
    StrLen: Integer;    <span class="pas-comment">// the length of the string</span>
    PBuf: PChar;        <span class="pas-comment">// buffer to hold the string that is read</span>
  <span class="pas-kwd">begin</span>
    <span class="pas-comment">// Get length of string (as 32 bit integer)</span>
    ReadBuffer(StrLen, SizeOf(Integer));
    <span class="pas-comment">// Now get string</span>
    <span class="pas-comment">// allocate enough memory to hold string</span>
    GetMem(PBuf, StrLen);
    <span class="pas-kwd">try</span>
      <span class="pas-comment">// read chars into buffer and set resulting string</span>
      ReadBuffer(PBuf^, StrLen);
      SetString(Result, PBuf, StrLen);
    <span class="pas-kwd">finally</span>
      <span class="pas-comment">// deallocate buffer</span>
      FreeMem(PBuf, StrLen);
    <span class="pas-kwd">end</span>;
  <span class="pas-kwd">end</span>;

  <span class="pas-kwd">procedure</span> TStrStream.WriteString(AString: <span class="pas-kwd">string</span>);
  <span class="pas-kwd">var</span>
    Len: Integer;     <span class="pas-comment">// length of string</span>
  <span class="pas-kwd">begin</span>
    <span class="pas-comment">// Write out length of string as 32 bit integer</span>
    Len := Length(AString);
    WriteBuffer(Len, SizeOf(Integer));
    <span class="pas-comment">// Now write out the string's characters</span>
    WriteBuffer(PChar(AString)^, Len);
  <span class="pas-kwd">end</span>;</pre>
  <div class="footer">Listing 4</div>
  </div>

  <p>
    The following code should demonstrate how to write a string to a file and
    read it back in again. Here we use a file stream that is created on the fly
    and automatically closed when we are done. Of course you could use any
    stream type and handle its lifetime yourself.
  </p>

  <div class="frame">
  <!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
  <pre class="pas-source"><span class="pas-kwd">procedure</span> WriteText(<span class="pas-kwd">const</span> Txt: <span class="pas-kwd">string</span>);
  <span class="pas-kwd">var</span>
    TS: TTextStream;
  <span class="pas-kwd">begin</span>
    <span class="pas-comment">// This opens stream on a file stream that will </span>
    <span class="pas-comment">// be closed when this stream closes</span>
    TS := TTextStream.Create(
      TFileStream.Create(<span class="pas-str">'test.dat'</span>, fmCreate), True);
    TS.WriteString(Txt);
    TS.Free;  <span class="pas-comment">// this also closes wrapped file stream</span>
  <span class="pas-kwd">end</span>;

  <span class="pas-kwd">function</span> ReadText: <span class="pas-kwd">string</span>;
  <span class="pas-kwd">var</span>
    TS: TTextStream;
  <span class="pas-kwd">begin</span>
    TS := TTextStream.Create(
      TFileStream.Create(<span class="pas-str">'test.dat'</span>, fmCreate), True);
    Result := TS.ReadString;
    TS.Free;
  <span class="pas-kwd">end</span>;</pre>
  <div class="footer">Listing 5</div>
  </div>

  <p>
    The filter in this example provides additional methods to those in
    <var>TSteamWrapper</var>. We can also provide filters that override the
    <var>Read</var> and <var>Write</var> methods to alter the way that files are
    written.
  </p>


  <h2>
    Worked Example
  </h2>

  <p>
    You can download a <?php
    echo DocPart::DownloadTextLink('art-5', '', 'worked example');
    ?> of the above code. The zip file contains a Delphi 4 project that writes
    out some user provided strings to a file using the <var>TStrStream</var>
    class, and reads them back in again.
  </p>


  <h2>
    Stream Extension Classes
  </h2>

  <p>
    My <?php
    echo DocPart::SoftwareTextLink('streams', 'Stream Classes');
    ?> provide an example of the techniques described here.
  </p>
