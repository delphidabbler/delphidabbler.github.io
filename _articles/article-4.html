---
article: 4
title: "How to remember a window's size, state and position"
summary: "When I open an application I like to have it remember the size and position of its window when it was last closed. Here's how to do it with Delphi forms."
pages: 1
---
<h2>
  Why do it?
</h2>

<p>
  It's often useful to remember the size and state of your program's windows between executions. This article discusses how.
</p>


<h2>
  How it's done
</h2>

<p>
  The method we're going to use is to save the position in the registry. I won't discuss details of how to access the registry from code in depth here. First of all, decide where in the registry you're going to keep the information. It's customary for applications to place information that varies between users in:
</p>

<pre class="pre-scrollable">HKEY_CURRENT_USER\Software\MyCompany\MyProgram\X.X</pre>

<p>
  (where <code>X.X</code> is the version number of the program). We'll use such a key in this article.
</p>

<p>
  You can save the window's current position and size when the program is closing down &ndash; the <var>OnDestroy</var> form event handler is a good place for this. The program then restores it's position from the registry (if it's been written yet) when opening &ndash; we use the form's <var>OnCreate</var> handler for that code.
</p>

<p>
  There are complications when saving and restoring the window state. When the window is minimised, Delphi doesn't minimise the form &ndash; it hides it and displays the Application window in the taskbar. The method I've used causes a previously minimised window to flash on-screen briefly. I'd welcome ideas on any alternative approaches.&dagger;
</p>

<aside>
	<p class="alert alert-info ">
		<span class="bg-primary">&nbsp;&dagger;&nbsp;</span>&ensp;The later releases of my <a href="{{ site.base-url }}/software/wdwstate">Window State Components</a> solve the minimisation problem. However the solution is quite involved. You are welcome to read the component code if you are interested.
	</p>
</aside>

<p>
  Another complication is that when a window is maximised Delphi updates the <var>Width</var>, <var>Height</var>, <var>Left</var> and <var>Top</var> properties of the form to the window's maximised size and position. This means that closing a maximised window stores the maximised size in the registry. When the program is run again it appears maximised, but when the user restores it they expect it to go to the previous normal size and position, but if we reloaded the <var>Left</var>, <var>Top</var>, <var>Height</var> and <var>Width</var> properties, the form won't shrink when restored. We get round this by using the Windows API to get the non-maximised size.
</p>

<p>
  Here's the code &ndash; the comments should explain what's happening.
</p>

<div class="frame" id="listing-1">
<!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
<pre class="pas-source kbd"><span class="pas-kwd">const</span>
  CRegKey = <span class="pas-str">'Software\Demos\WdwStateDemo\1.0'</span>;

<span class="pas-comment">// Helper function to read registry values, and</span>
<span class="pas-comment">// deal with cases where no values exist</span>
<span class="pas-kwd">function</span> ReadIntFromReg(Reg: TRegistry;
  <span class="pas-kwd">Name</span>: <span class="pas-kwd">string</span>; Def: Integer): Integer;
  <span class="pas-comment">{Reads integer with given name from registry</span>
<span class="pas-comment">  and returns it. If no such value exists, returns</span>
<span class="pas-comment">  Def default value}</span>
<span class="pas-kwd">begin</span>
 <span class="pas-kwd">if</span> Reg.ValueExists(<span class="pas-kwd">Name</span>) <span class="pas-kwd">then</span>
    Result := Reg.ReadInteger(<span class="pas-kwd">Name</span>)
  <span class="pas-kwd">else</span>
    Result := Def;
<span class="pas-kwd">end</span>;

<span class="pas-kwd">procedure</span> TForm1.FormDestroy(Sender: TObject);
<span class="pas-kwd">var</span>
  Reg: TRegistry;         <span class="pas-comment">// the registry</span>
  State: Integer;         <span class="pas-comment">// state of window</span>
  Pl : TWindowPlacement;  <span class="pas-comment">// used for API call</span>
  R: TRect;               <span class="pas-comment">// used for window pos</span>
<span class="pas-kwd">begin</span>
  <span class="pas-comment">{Calculate window's normal size and position</span>
<span class="pas-comment">  using Windows API call - the form's Width, Height,</span>
<span class="pas-comment">  Top and Left properties will give maximised window</span>
<span class="pas-comment">  size if form is maximised, which is not what we</span>
<span class="pas-comment">  want here}</span>
  Pl.Length := SizeOf(TWindowPlacement);
  GetWindowPlacement(Self.Handle, @Pl);
  R := Pl.rcNormalPosition;
  Reg := TRegistry.Create;
  <span class="pas-kwd">try</span>
    <span class="pas-comment">// Open required key - create if doesn't exist</span>
    Reg.RootKey := HKEY_CURRENT_USER;
    Reg.OpenKey(CRegKey, True);
    <span class="pas-comment">// Write window size and position</span>
    Reg.WriteInteger(<span class="pas-str">'Width'</span>, R.Right-R.Left);
    Reg.WriteInteger(<span class="pas-str">'Height'</span>, R.Bottom-R.Top);
    Reg.WriteInteger(<span class="pas-str">'Left'</span>, R.Left);
    Reg.WriteInteger(<span class="pas-str">'Top'</span>, R.Top);
    <span class="pas-comment">// Write out state of window</span>
    <span class="pas-comment">{Record window state (maximised, minimised or</span>
<span class="pas-comment">    normal) - special case when minimised since form</span>
<span class="pas-comment">    window is simply hidden when minimised, and</span>
<span class="pas-comment">    application window is actually the one</span>
<span class="pas-comment">    minimised - so we check to see if application</span>
<span class="pas-comment">    window *is* minimised and act accordingly}</span>
    <span class="pas-kwd">if</span> IsIconic(Application.Handle) <span class="pas-kwd">then</span>
      <span class="pas-comment">{minimised - write that state}</span>
      State := Ord(wsMinimized)
    <span class="pas-kwd">else</span>
      <span class="pas-comment">{not minimised - we can rely on window state</span>
<span class="pas-comment">      of form}</span>
      State := Ord(Self.WindowState);
    Reg.WriteInteger(<span class="pas-str">'State'</span>, State);
  <span class="pas-kwd">finally</span>
    Reg.Free;
  <span class="pas-kwd">end</span>;
<span class="pas-kwd">end</span>;

<span class="pas-kwd">procedure</span> TForm1.FormCreate(Sender: TObject);
<span class="pas-kwd">var</span>
  Reg: TRegistry;   <span class="pas-comment">// the registry</span>
  State: Integer;   <span class="pas-comment">// state of window</span>
<span class="pas-kwd">begin</span>
  Reg := TRegistry.Create;
  <span class="pas-kwd">try</span>
    <span class="pas-comment">// Open required key - exit if it doesn't exist</span>
    Reg.RootKey := HKEY_CURRENT_USER;
    <span class="pas-kwd">if</span> <span class="pas-kwd">not</span> Reg.OpenKey(CRegKey, False) <span class="pas-kwd">then</span> Exit;
    <span class="pas-comment">// Read the window size and position</span>
    <span class="pas-comment">// - designed form sizes are defaults</span>
    Self.Width := ReadIntFromReg(Reg, <span class="pas-str">'Width'</span>, Self.Width);
    Self.Height := ReadIntFromReg(Reg, <span class="pas-str">'Height'</span>, Self.Height);
    Self.Left := ReadIntFromReg(Reg, <span class="pas-str">'Left'</span>, Self.Left);
    Self.Top := ReadIntFromReg(Reg, <span class="pas-str">'Top'</span>, Self.Top);
    <span class="pas-comment">// Now get window state and restore</span>
    State := ReadIntFromReg(Reg, <span class="pas-str">'State'</span>, Ord(wsNormal));
    <span class="pas-comment">{check if window was minimised - we have special</span>
<span class="pas-comment">    processing for minimised state since Delphi</span>
<span class="pas-comment">    doesn't minimise windows - it uses application</span>
<span class="pas-comment">    window instead}</span>
    <span class="pas-kwd">if</span> State = Ord(wsMinimized) <span class="pas-kwd">then</span>
    <span class="pas-kwd">begin</span>
      <span class="pas-comment">{we need to set visible true else form won't</span>
<span class="pas-comment">      restore properly - but this causes a brief</span>
<span class="pas-comment">      display of form.</span>
<span class="pas-comment">      Any ideas on how to stop this?}</span>
      Self.Visible := True;
      Application.Minimize;
    <span class="pas-kwd">end</span>
    <span class="pas-kwd">else</span>
      Self.WindowState := TWindowState(State);
  <span class="pas-kwd">finally</span>
    Reg.Free;
  <span class="pas-kwd">end</span>;
<span class="pas-kwd">end</span>;</pre>
<div class="caption">Listing 1</div>
</div>


<h2>
  Worked Example
</h2>

<p>
	A demo project that demonstrates what we've described in this article can be found on the <code><a href="https://github.com/delphidabbler/article-demos">delphidabbler/article-demos</a></code> Git repository on GitHub.
</p>

<p>
	You can view the code in the <code>article-04</code> sub-directory. Alternatively download a zip file containing all the demos by going to the repository's landing page and clicking the <em>Clone or download</em> button and selecting <em>Download ZIP</em>.
</p>


<h2>
  Component
</h2>

<p>
  My <a href="{{ site.base-url }}/software/wdwstate">TPJRegWdwState component</a> encapsulates all this functionality on behalf of the form that owns it. A sister component, <var>TPJWdwState</var>, is included that works with ini files rather than the registry.
</p>
