---
article: 2
title: "How to store files inside an executable program"
summary: "Its sometimes useful to be able to distribute read-only files embedded in your programs. This article explains why and discusses how."
meta-title: "Use Delphi Pascal to store files inside an executable program | How to"
meta-desc: "An article that shows how to use Delphi Pascal to embed data files in a Windows program's resources by creating a resource file that is then compiled into the program."
demo-url: "https://github.com/delphidabbler/article-demos/tree/master/article-02+03"
link-next: "/articles/article-3"
pages: 1
index: true
redirect_from:
- /articles/2
---
<h2>
    Why do it?
  </h2>

  <p>
    Have you ever needed to distribute one or more critical data files with a program? Often only your program needs to access the data file(s) and they don't need to be changed by it. How do we stop users from deleting the files? One answer is to store the data file inside our executable (or in a DLL) as a custom (<var>RCDATA</var>) resource and to link the resource into our application using the <span class="pas-preproc">{$R}</span> directive.
  </p>

  <p>
    This article shows how to create a resource file containing a copy of any file.
  </p>


  <h2>
    How it's done
  </h2>

  <p>
    The resource file we're going to create has the following format:
  </p>

  <ul>
    <li>
      a header that introduces the file
    </li>
    <li>
      a header for our <var>RCDATA</var> resource
    </li>
    <li>
      the data itself - an <var>RCDATA</var> resource is simply a sequence of bytes
    </li>
    <li>
      any padding required so that any following resource begins on a <var>DWORD</var> boundary
    </li>
  </ul>

  <p>
    It's much simpler to create a resource file that is identified by an ordinal (e.g. 200) than it is to create one identified by a string (e.g. 'MY_RESOURCE'), since the resource header records are a fixed size in the first case and are variable in the second case. We will only consider the first case here. We will also just copy one file into the resource &ndash; it's simple to extend this to more than one.
  </p>

  <p>
    Because we're sticking with ordinal IDs the resource header can be defined as:
  </p>

  <!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
  <div class="frame">
  <pre class="pas-source">TResHeader = <span class="pas-kwd">record</span>
    DataSize: DWORD;        <span class="pas-comment">// size of our data      </span>
    HeaderSize: DWORD;      <span class="pas-comment">// size of this record</span>
    ResType: DWORD;         <span class="pas-comment">// lo word = $FFFF =&gt; ordinal</span>
    ResId: DWORD;           <span class="pas-comment">// lo word = $FFFF =&gt; ordinal</span>
    DataVersion: DWORD;     <span class="pas-comment">// *</span>
    MemoryFlags: WORD;
    LanguageId: WORD;       <span class="pas-comment">// *</span>
    Version: DWORD;         <span class="pas-comment">// *</span>
    Characteristics: DWORD; <span class="pas-comment">// *</span>
  <span class="pas-kwd">end</span>;</pre>
  <div class="footer">Listing 1</div>
  </div>

  <p>
    We will not be using the fields marked *.
  </p>

  <p>
    Here's the code that creates the resource file and copies in a given file:
  </p>

  <div class="frame">
  <!-- Highlighted Pascal code generated by DelphiDabbler PasH -->
  <pre class="pas-source"><span class="pas-kwd">procedure</span> CreateResourceFile(
    DataFile, ResFile: <span class="pas-kwd">string</span>;  <span class="pas-comment">// file names</span>
    ResID: Integer              <span class="pas-comment">// id of resource</span>
  );
  <span class="pas-kwd">var</span>
    FS, RS: TFileStream;
    FileHeader, ResHeader: TResHeader;
    Padding: <span class="pas-kwd">array</span>[<span class="pas-num">0</span>..SizeOf(DWORD)-<span class="pas-num">1</span>] <span class="pas-kwd">of</span> Byte;
  <span class="pas-kwd">begin</span>

    <span class="pas-comment">{ Open input file and create resource file }</span>
    FS := TFileStream.Create(  <span class="pas-comment">// to read data file</span>
      DataFile, fmOpenRead);
    RS := TFileStream.Create(  <span class="pas-comment">// to write res file</span>
      ResFile, fmCreate);

    <span class="pas-comment">{ Create res file header - all zeros except</span>
  <span class="pas-comment">    for HeaderSize, ResType and ResID }</span>
    FillChar(FileHeader, SizeOf(FileHeader), <span class="pas-str">#0</span>);
    FileHeader.HeaderSize := SizeOf(FileHeader);
    FileHeader.ResId := <span class="pas-hex">$0000FFFF</span>;
    FileHeader.ResType := <span class="pas-hex">$0000FFFF</span>;

    <span class="pas-comment">{ Create data header for RC_DATA file </span>
  <span class="pas-comment">    NOTE: to create more than one resource just</span>
  <span class="pas-comment">    repeat the following process, using a different</span>
  <span class="pas-comment">    resource ID each time }</span>
    FillChar(ResHeader, SizeOf(ResHeader), <span class="pas-str">#0</span>);
    ResHeader.HeaderSize := SizeOf(ResHeader);
    <span class="pas-comment">// resource id - FFFF says &quot;not a string!&quot;</span>
    ResHeader.ResId := <span class="pas-hex">$0000FFFF</span> <span class="pas-kwd">or</span> (ResId <span class="pas-kwd">shl</span> <span class="pas-num">16</span>);
    <span class="pas-comment">// resource type - RT_RCDATA (from Windows unit)</span>
    ResHeader.ResType := <span class="pas-hex">$0000FFFF</span>
      <span class="pas-kwd">or</span> (WORD(RT_RCDATA) <span class="pas-kwd">shl</span> <span class="pas-num">16</span>);
    <span class="pas-comment">// data file size is size of file</span>
    ResHeader.DataSize := FS.Size;
    <span class="pas-comment">// set required memory flags </span>
    ResHeader.MemoryFlags := <span class="pas-hex">$0030</span>;

    <span class="pas-comment">{ Write the headers to the resource file }</span>
    RS.WriteBuffer(FileHeader, SizeOf(FileHeader));
    RS.WriteBuffer(ResHeader, SizeOf(ResHeader));

    <span class="pas-comment">{ Copy the file into the resource }</span>
    RS.CopyFrom(FS, FS.Size);

    <span class="pas-comment">{ Pad data out to DWORD boundary - any old </span>
  <span class="pas-comment">    rubbish will do!}</span>
    <span class="pas-kwd">if</span> FS.Size <span class="pas-kwd">mod</span> SizeOf(DWORD) &lt;&gt; <span class="pas-num">0</span> <span class="pas-kwd">then</span>
      RS.WriteBuffer(Padding, SizeOf(DWORD) -
        FS.Size <span class="pas-kwd">mod</span> SizeOf(DWORD));

    <span class="pas-comment">{ Close the files }</span>
    FS.Free;
    RS.Free;
  <span class="pas-kwd">end</span>;</pre>
  <div class="footer">Listing 2</div>
  </div>

  <p>
    The above code should be sufficient to illustrate the problem, but it is not very elegant &ndash; and the streams should be protected by <span class="keyword">try .. finally</span> blocks. A better solution is to create a class that encapsulates the code. A further improvement would be to permit either strings or ordinals to be used to identify the resource.
  </p>

  <p>
    On occasion you may want to write formatted data to the resource file rather than just copy a file &ndash; this is easy to do. You need to do five things:
  </p>

  <ol class="spaced">
    <li>
      Write a place-holder header record for your resource and record its position in the stream.
    </li>

    <li>
      Write the formatted data to the file (replace the code that copies the file with code that writes the data).
    </li>

    <li>
      Keep a record of the size of the data you are writing.
    </li>

    <li>
      Pad the data out to a <var>DWORD</var> boundary.
    </li>

    <li>
      Store the length of data (excluding padding) in your header record, return to the position of the place-holder.
    </li>
  </ol>

  <p>
    Of course there's now the problem of getting the file information back out of the executable! This is quite a trivial process and is dealt with in <?php echo $gLinker->InterLink(3, 0, '', 'another article'); ?>.
  </p>


  <h2>
    Worked Example
  </h2>

  <p>
    You can download a <?php echo DocPart::DownloadTextLink('art-2-3', '', 'worked example'); ?> that demonstrates what has been described here &ndash; it uses the above code. The zip file contains a pair of projects. The first a program that embeds a supplied rich text file in a resource file. The second program includes the resource file and displays the rich text in a rich edit component.
  </p>
